import numpy as np
import random

import numpy as np
import random

class AntColonyOptimizer:
    def __init__(self, distance_matrix, num_ants, evaporation_rate, alpha, beta, Q, max_fitness_evaluations, local_heuristic):
        self.distance_matrix = distance_matrix
        self.num_ants = num_ants
        self.evaporation_rate = evaporation_rate
        self.alpha = alpha
        self.beta = beta
        self.Q = Q
        self.max_fitness_evaluations = max_fitness_evaluations
        self.num_cities = distance_matrix.shape[0]

        self.eta = local_heuristic / (distance_matrix + np.finfo(float).eps)  # Eta is visibility, which is 1/distance
        self.eta[np.eye(self.num_cities, dtype=bool)] = 0  # Set diagonal to zero to avoid self-loop

        self.best_solution = None
        self.best_cost = float('inf')
        self.elitist_weight = 1  # Adjust as needed, this is the extra weight for the best ant

        # Initialize pheromone levels
        self.pheromone_matrix = np.random.uniform(low=0.1, high=1.0, size=(self.num_cities, self.num_cities))
        self.pheromone_delta = np.zeros_like(self.distance_matrix)

    def run(self):
        best_cost = float('inf')
        best_solution = None
        fitness_evaluations = 0

        start_city = 0  # Initialize start city

        while fitness_evaluations < self.max_fitness_evaluations:
            solutions = []

            for _ in range(self.num_ants):
                solution, cost = self.generate_solution(start_city)
                solutions.append((solution, cost))

                if cost < best_cost:
                    best_cost = cost
                    best_solution = solution

                fitness_evaluations += 1
                if fitness_evaluations >= self.max_fitness_evaluations:
                    break

            self.update_pheromones(solutions)
            self.evaporate_pheromones()
            
            # Inside the while loop, after generating solutions
            for solution, cost in solutions:
                if cost < self.best_cost:
                    self.best_cost = cost
                    self.best_solution = solution


            start_city = (start_city + 1) % self.num_cities  # Change start city for next iteration

        return best_solution, best_cost

    def generate_solution(self, start_city):
        path = [start_city]  # Start at the given city
        visited = set(path)

        while len(path) < self.num_cities:
            next_city = self.select_next_city(path[-1], visited)
            path.append(next_city)
            visited.add(next_city)

        cost = self.calculate_path_cost(path)
        return path, cost


    def select_next_city(self, current_city, visited):
        unvisited_cities = [city for city in range(self.num_cities) if city not in visited]
        probabilities = []

        for city in unvisited_cities:
            tau = self.pheromone_matrix[current_city][city] ** self.alpha
            eta = self.eta[current_city][city] ** self.beta  # Use precomputed eta value
            probabilities.append(tau * eta)

        total = sum(probabilities)
        if total <= 0:
            # Fallback: Choose randomly from remaining unvisited cities
            if unvisited_cities:
                return random.choice(unvisited_cities)
            else:
                raise Exception("No unvisited cities left, but path is incomplete. Check logic.")

        probabilities = [p / total for p in probabilities]  # Normalize probabilities
        next_city = random.choices(unvisited_cities, weights=probabilities, k=1)[0]
        return next_city

    def calculate_path_cost(self, path):
        path_array = np.array(path)
        return np.sum(self.distance_matrix[path_array[:-1], path_array[1:]]) + self.distance_matrix[path[-1], path[0]]


    def update_pheromones(self, solutions):
        # Reset the pheromone delta matrix
        self.pheromone_delta.fill(0)

        # Update pheromone for all ants
        for solution, cost in solutions:
            indices = np.array(solution)
            self.pheromone_delta[indices[:-1], indices[1:]] += self.Q / cost

        # Additional pheromone for the best solution so far
        if self.best_solution is not None:
            best_indices = np.array(self.best_solution)
            self.pheromone_delta[best_indices[:-1], best_indices[1:]] += self.elitist_weight * self.Q / self.best_cost

        # Update the pheromone matrix
        self.pheromone_matrix += self.pheromone_delta

    def evaporate_pheromones(self):
        self.pheromone_matrix *= (1 - self.evaporation_rate)

